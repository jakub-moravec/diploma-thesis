%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Návrh architektury}
Cílem této kapitoly práce je navrhnout a popsat architekturu, která bude řešit, či umožní budoucí řešení problémů popsaných v kapitole \ref{sec:ana_problems}. %todo dvě části ...

\section{Architektura modulu pro přístup k metadatovému uložišti}
Jak bylo uvedeno v sekci \ref{sec:ana_problems}, jedním z klíčových problémů, kterým v současné době aplikace \textit{Manta Flow} čelí je splývání byznys logiky aplikace s perzistenční logikou, která implementuje ukládání datových toků do grafové databáze a jejich dotazování. To je nejvíce patrné v modulu \textit{Connector}, který zajišťuje připojení aplikace k grafové databázi, vkládání a dotazování dat do/z grafové databáze (perzistenční logika) a poskytuje způsoby analýzy dat uložených v grafové databázi (algoritmy a traversaly - \ref{sec:ana_connector}), obsahuje tedy také značné množství byznys logiky serverové části aplikace. První částí návrhu architektury je tak změna architektury \textit{Manta Flow Serveru} tak, aby byl tento modul nahrazen vícevrstvou architekturou, která:

\begin{itemize}
   \item umožní připojení aplikace do grafové databáze,
   \item definuje operace, které tvoří persistenční logiku aplikace, pomocí \textit{API} a zamezí přímému přístupu do grafové databáze z jiných komponent,
   \item umožní přidělení/zamezení přístupu ke konkrétním informacím obsaženým v grafové databázi na základě definovaných oprávnění uživatelů a
   \item poskytne funkcionalitu pro pokrytí všech požadavků ostatních modulů serverové části aplikace
\end{itemize}

Hlavní kvalitativní kritéria zvolené architektury, které vycházejí z těchto požadavků, jsou:

\begin{itemize}
   \item{\textit{Jednoduchost}}: Zvolená architektura musí maximalizovat princip separace zájmů. Tím bude výrazně snížena závislost (\textit{coupling}) byznys logiky aplikace a persistenční logiky a bude docíleno jednoduchosti komponent.
   \item{\textit{Viditelnost}}: Komunikace mezi jednotlivými komponentami musí být přímočará a musí být rozšířitelná o novou komponentu. Aktuálně existuje požadavek na začlenění komponenty, která bude řídit přístup uživatele k informacím uloženým v metadatovém uložišti na základě oprávnění uživatele.
   \item{\textit{Modifikovatelnost}}: Jednotlivé komponenty musí být jednoduše rozšířitelné. Musí být snadné přidávání komponent. Implementace (některých) komponent musí být zaměnitelná bez dopadů na další komponenty (jedná se především o implementaci komponenty implementující perzistenční logiku aplikace - kvůli možné výměně grafové databáze a tedy i dotazovacího jazky).
   \item{\textit{Výkon}}: V kapitole \ref{sec:ana_performance} jsou popsány požadavky na výkon (především) serverové části aplikace \textit{Manta Flow}. Architektura musí umožňovat splnění těchto požadavků a musí být definovány možné způsoby optimalizace výkonu.
\end{itemize}

\subsection{Transakční model a řízení konzisence dat}
\label{sec:des_transactions}
Jak je popsáno v kapitole \ref{sec:ana_transactions}, aplikace \textit{Manta Flow} má velmi specické požadavky týkající se řízení datové konzistence metadatového uložiště. Jedná se o problém, který je koncepční a může mít podstatné dopady na architekturu aplikace.

Bylo uvedeno, že stávající řešení používá \textit{programatický} transakční model, transakce jsou mezi jednotlivými komponentami serverové části aplikace propagovány jako objekty a jsou používány k přímému přístupu do databáze. Cílený stav je takový, aby byl přímí přístup do databáze možný pouze z z komponenty k tomu určené a ostatní komponenty (obsahující byznys logiku aplikace) pro přístup do databáze vždy používali tuto komponentu. Současně ale musí být umožněno propagování transakcí mimo tuto komponentu, transakce jsou často rozsáhlé\footnote{Úroveň izolací \textit{snapshot isolation} vyplývající z \textit{MVCC} implementace transakcí používané grafovými databázemi je specifická v tom, že je v průběhu transakce duplikováno velké množství databázových objektů. Ty jsou navíc často ukládány do paměti klientské služby, nikoliv databáze. Pro optimalizaci přístupů do grafové databáze je tak podstatné zvolení správné velikosti transakcí. V případě minimalistických transakcí zahrnujících jednotky operací je režie transakcí příliš velká a práce s databází není efektivní. Při příliš rozsáhlých transakcích dochází k vyčerpání operační paměti klientské služby kvůli duplikování databázových objektů.}. Je tedy nutné zavést mechanismus \textbf{abstrakce transakcí}.
V aplikacích používajích relační databáze je k tomuto účelu standardně používán \textbf{deklarativní transakční model}. Ten umožňuje konfigurovat chování každé metody, která přistupuje do datového zdroje (v tomto případě databáze), nebo která takovou metodu volá. U každé takové metody je definováno, jak má být transakce propagována, jaký je stupeň izolace transakce, zda je \textit{read-only} a v jakém případě dochází k \textit{rollbacku} transakce. Implementace tohoto modelu frameworkem \textit{Spring} je popsána v dokumentaci \cite{SpringTransactions}.
V kontextu grafových databázích ale pro tento model zatím není u řady databází podpora a o standardní řešení se nejedná. Součástí návrhové fázy tak bylo vytvoření dvou \textit{PoC} implementací (TODO odkazy), které ověřují použitelnost tohoto řešení pro dotazovací jazyk \textit{Gremlin} ve verzi \textit{2.x} a \textit{3.x}. V obou případech bylo ověřeno, že použití \textit{deklarativního transakčního modelu} v kombinaci s frameworkem \textit{Spring} je pro aplikaci \textit{Manta Flow} vhodným řešením. Podpora pro jazyk \textit{Gremlin} ve zmíněných verzích, respektive pro databáze, které ho podporují, byla v rámci těchto \textit{PoC} implementována vlastní - existující implementace (uvedené v kapitole \ref{sec:ana_transactions}) jsou dostupné pouze v experimentálních verzích a obsahují chyby.
Důležitým omezením, které vyplývá ze zvoleného řešení je, že všechny komponenty, do kterých jsou propagovány transakce musí být součástí monolitické architektury - není možná propagace transakcí pomocí standardních komunikačních protokolů (například \textit{HTTP/s}).

Dalším faktorem ovlivňující architekturu serverové části aplikace, který se týká datové konzistence, je systém explicitních zámků. Ten zajišťuje synchronizaci (serializaci) paralelních přístupů do grafové databáze - na úrovni celé detabáze může v jednu chvíli existovat pouze jedna zapisovací transakce (popsáno v kapitole \ref{sec:ana_transactions}). Tento systém je velkým omezením pro architekturu aplikace, protože zabraňuje jejímu (efektivnímu) škálování. Systém zámků je nutný - pokud by nebyl používán, docházelo by k zanášení nekonzistencí do metadatového uložiště a to především k duplikacím objektů\footnote{Potenciální alternativou k systémů zámků by bylo zavedení unikátních identifikátorů uzlů a vytvoření indexů hlídajících tuto vlastnost. V tom případě by nedocházelo k duplikaci uzlů a používání zámků by nebylo nutné. Používání unikátních indexů v grafových databázích ale není obecně příliš efektivní. Uzly typu \textit{NODE} navíc žádné přirozené unikátní identifikátory nemají, respektive jejich vytvoření by vedlo často na řetězce obsahující stovky znaků. Tento přístup byl tedy zavržen.}. Je tedy nutné tento systém upravit tak, aby lépe vyhovoval požadavků aplikace. Konkrétně byl navržen algoritmus pro zamykání objektů uložených v metadatovém uložišti definovaný následujícím chováním:

\begin{itemize}
   \item zamykány jsou uzly v grafové databázi,
   \item existují dvě úrovně zámků - pro čtení a pro zápis,
   \item zámky pro čtení jsou uplatňovány pouze v případě, že je čteno z \textit{necommitnuté} revize,
   \item při úpravě vlastností uzlu (zpravidla úprava intervalu platnosti uzlu) je zamykán tento uzel,
   \item při vytváření novéhu uzlu je zamykán uzel, který je předkem uzlu,
   \item při mazání uzlu je zamykán uzel, který je předkem uzlu,
   \item v případě situace vedoucí k potencionálnímu \textit{dead-locku} dojde ke \textit{commitu} všech zůčastněných transakcí a zpracování dalších uzlů v nové transakci
\end{itemize}

Operace, které by i nadále měly zamykat celou databázi jsou promazávání starých revizí a export či import kompletního dumpu databáze.

Takto navržený systém zámků umožní paralelní zápis do metadatového uložiště (byť zrychlení kvůli zamykání objektů a tedy potenciálnímu čekání v praxi nebude dosahovat počtu paralelních procesů). I tak ale existuje silná závislost mezi architektonickými omezeními aplikace a omezeními na implementaci zámků. \textit{Gremlin} (v žádné verzi) neposkytuje vlastní řešení zámků v grafových databázích. Zamykat objekty databáze pomocí databázových zámků je tak možné pouze u některých grafových databází. Nabízí se tak možnost sychnronizace pomocí \textit{Java} konstruktů, jakou jsou \textit{synchronized} metody/bloky, zámky, atomické proměnné atd. Tyto nástroje je ale možné použít pouze v případě zachování monolitické architektury serverové části aplikace. V případě její rozdělení na  komponety spouštěné na různých \textit{JVM} by bylo pro synchronizaci zámků nutné používat externí nástroje jako například relační databáze, nebo specifické nástroje jako je \textit{Redisson}\footnote{\url{https://redisson.org/}}.

Vzhledem k tomu, že systém zámků řeší konzistenci dat z pohledu byznys logiky aplikace (integrita dat je zajištěna používáním transakcí), měl by být implementován komponentou obsahující tuto byznys logiku - konkrétně modul \textit{Merger} (kapitola \ref{sec:ana_merger}), který může jako jediná komponenta implementující byznys logiku aplikace pracovat s \textit{necommitnutou} revizí metadatového uložiště.

\subsection{Návrh komponent}
\label{sec:des_components}
V zádání diplomové práce je navržno, aby byl jako architektonický styl pro návrh architektury splňující uvedená kritéria zvolena vícevrstvá architektura. Ta uvedeným kritériím zcela vyhovuje. Navržená architektura je popsána \textit{UML\footnote{Unified Modeling Languege. Používaná notace 2.5.1 \cite{UML17}} diagramem komponent} \ref{TODO} a jednotlivé její komponenty jsou popsány v následujícíh podkapitolách.

\subsubsection{Doménový model}
\label{sec:des_domain}
Jedním z důsledků splývání byznys a persistenční logiky je absence doménového objektové modelu serverové části aplikace. Místo něj je používán obecný model založený na třídách \textit{Vertex} (vrchol) a \textit{Edge} (hrana). Tato reprezentace dat v aplikaci má dva zásadní dopady:

\begin{itemize}
   \item Model je příliš obecný (dokáže pojmout graf jakékoliv struktury, potažmo graf bez definované struktury), datový model metadatového uložiště je ale přesně specifikovaný (diagram \ref{fig:ana-model}) a jeho nedodržení by znamenola zanesení nekonzistence a tedy riziko selhání aplikace.
   \item Vzhledem k tomu, že zmíněný model poskytuje jako \textit{SPI} dotazovací jazyk \textit{Gremlin} (respektive \textit{API Blueprints}) a to je implementováno \textit{Java} knihovnou pro práci s grafovou databází \textit{Titan}, umožňují instance tohoto modelu přímý přístup do grafové databáze.
\end{itemize}

Je evidentní, že tento doménový model není pro navrženou architekturu vhodný, byl tak vytvořen vlastní, \textbf{specifický doménový model}.

Základními omezeními návrhu doménového modelu jsou:
\begin{itemize}
   \item{\textit{Rich model}}: Doménový model je navržen jako tzv. \textit{rich domain model}, obsahuje nejen definice entint a jejich parametrů, ale také základní logiku, kterou tyto entity a vazby mezi nimi představují.
   \item{\textit{POJO model}}: Doménový model by měl být tvořen pouze \textit{POJO třídami} \footnote{\textit{POJO (Plain Old Java Object)} je označení pro \textit{obyčejný Java objekt}, tedy objekt, který není \textit{J2EE Bean, Spring Bean, Entity Bean,}  atd.}.
   \item{\textit{Model neobsahuje perzistenční logiku}}: Součástí doménového modelu by neměla být perzistenční logika. Toto omezení je v podstatě důsledkem omezení na \textit{POJO} objekty - obsahoval-li by doménový model perzistenční logiku, musel by nutně obsahovat také transakční logiku, která je ale navržna tak (kapitola TODO), že není realizovatelná pomocí \textit{POJO} objektů. Perzistenční logika je tak realizovaná samostatnou komponentou (kapitola \ref{sec:des_persistence}).
\end{itemize}

\subsubsection{Databázová vrstva}
\label{sec:des_database}

\subsubsection{Perzistentní vrstva}
\label{sec:des_persistence}
Jak je zmíněno v kapitole \ref{sec:ana_state_of_art}, žádný ze zkoumaných nástrojů pro abstrakci objektově-grafového mapování nevyhovuje požadavkům \textit{Manta Flow} a navržená architektura tak s žádný takový nástroj nepoužívá. Místo toho je navržena vlastní abstraktní softwarová vrstva, která toto mapování provádí.

\subsubsection{Vrstva datového přístupu}
\label{sec:des_data_access}

\subsubsection{Algoritmy}

\subsubsection{Traversal}






\section{Globální architektura aplikace}
TODO



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO vlastní vrstva řešící licence (licence na moduly vs licence na počty skriptů)

% Vrstvy:
% FilterLayer      - vrstva uplatňující filtry dle oprávnění (asi vhodné přejmenovat)
% Algorithm/Traversal layer - vrstva algoritmů a traversalů, resp. "business" v kontextu DAL, neměla by sahat přímo do DB. Tatvo vrstva by možná měla obsahovat ještě sourozence Index (lucene) a DAO (most na operations).
% "PredicateLayer" - vrstva provádějící drobný filtering výsledků z OperationsLayer (vypreparovat z operations). Je otázka, jestli je vrstva potřeba, některé filtry se totiž můžu naopak přesunout dolů, do Gremlin dotazů.
% OperationsLayer  - základní operace nad grafovou databází, jediná vrstva, která by měla přímo šahat do db (s výjimkou zanořování transakcí)
% ConnectionLayer  - konektor, pouze kód nutný k připojení do db a spouštění dotazů
% DB
%
% Model -stranou

% Rozdělení modulů na API a impl dle https://stackoverflow.com/questions/14856225/maven-separate-modules-for-interfaces-and-implementation-with-spring

% Konzistence
% - transakce deklarativní, u write operací mandatory propagation
%    - umožní občasné commity kvůli performance? - ANO, pomocnou metodou
%    - implementace pro Spring jsou v divném stavu, nebo nejsou, vadí to? - ???
%          - je potřeba zjistit, co by znamenalo implementovat pro gremlin 3, pokud by to bylo rozumné, není problém
%          - zjistit, jak udělat custom abstrakci transakcí
%          - zjistit, jak se dá customizovat rollback u deklarativních transakcí a jestli je to potřeba
% - zámky (long living transakce)
%    - Je potřeba řešit následující situace:
%       - vytváření nové verze (zámek na pracovní revizi)
%       - prune revizí
%       - dump revizí
%    a) AS IS (tzn read vs write na celou db)
%    b) zámky na jednotlivé revize (lock id v db na objektu revize)
% - merge bez VCS - v jakých případech? Je vlastní revize pro Merge? Pokud ne, jak to ovlivní výkon (je stále potřeba concurrent read-write)?

% performance
% - zámky na rodiče
% :: CLI běží typicky ve čtyřech vláknech, ta po skončení (zhruba stejný čas) provolávají server - merger. Ten tedy také běží paralelně
% ve čtyřech vláknech (vytváření objektů v db). V současné době zámek přidělující write transakce způsobuje, že jsou tato čtyři vlákna
% v podstatě serializována (respektive spíš doslova).
% Jednou z možností, jak toto vyřešit je navrhnout zámky o menší granularitě - na rodiče (tedy v tomto pořadí: super_root, resourcy, nody různých úrovní..). Tyto zámky by byly Javovské (pokud by se měnila architektura na cloud, tak by se musely propagovat do DB).
% :: Mechanismus pro uzly: při vytváření uzlu zámek na jeho rodiče. V rámci jedné transakce by takto byla vytvořená dávka uzlů e.g. 500, po commitu by byly všechny zámky uvolněny (zámky nemohou být uvolněny dříve, ostatní vlákna by neviděla výsledek - read commited).
% Pokud by mělo dojít k deadlockové situaci (vlákno má zámek na nějaké uzly, ale čeká na jiné zámky, které má jiné vlákno), provede se předčasný commit (zmenší se dávka) a tím se zámky uvolní.
% :: Mechanismus pro (flow) hrany: TODO
% Premisy:
%  - jak výchozí, tak koncový vrchol již nutně musí existovat (byly na začátku stejného CSV)
% Návrhy:
%  - mělo by stačit zamykat výchozí vrchol (hrany by byly vytvářeny jen ze směru z->do)
%  - kdyby u hran byl odkaz i na rodiče zdroje (např. na tabulku sloupečku), stačilo by zamknout tabulku a flow hrany pod tímto zámkem vložit všechny (TODO jsou hrany seřazeny po tabulkách, nebo náhodně?)
% read lock = nolock ?
% zámky na revize pro stop-the world?


%\subsection{Architektonická omezení}
% Podněty
% - Architektura vyhovující cloudovým požadavkům
%  - žádný filesystem, jen pipes na jiné služby, které mohou filesystem podporovat (lze využívat pouze temp uložiště a sfree buckety)
%  - např jedna služba client, jedna server, jedna grafovka
%  - jak by se řešily veškeré konfigurace

% Škálovatelnost - cloud
% https://acloud.guru/
% https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420
% https://martinfowler.com/articles/microservices.html
% https://martinfowler.com/tags/application%20architecture.html - Serverless Architectures on AWS
% https://www.youtube.com/watch?v=LAWjdZYrUgI
% AWS Lambda - amazon SaaS (?)
% S3 - cloud storage (?)
% Cloud computing http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-145.pdf
% JPMC GAIA https://www.americanbanker.com/news/unexpected-champion-of-public-clouds-jpmorgan-cio-dana-deasy
% Cloud Awareness ;  OpenStack
